Development Process


Design 

Since I've most recently worked with JS (React, specifically), I tried to come up with a basic design and theme that I would be comfortable with implementing in a short time. I came up with the general design fairly quickly (a "hub" from where the events could be accessed from, different pages - rendered dynamically - for more details about each event, and different pages for the login flow and writeup). I considered keeping everything in one page (using accordions or modals instead to hold more information), but I thought that routing would make the 4th criterium (linking to related events) more manageable, so I went with this multi-page structure. Since I needed routing, I decided to use react-router (which I've also used in the past), and for a relatively quick design, I also used the React Bootstrap library (as well as its icons).


Problems/Issues I ran into

Although I have some experience with writing web applications in React, I've never fully implemented even a basic login flow, and so I was a bit worried that the 3rd criterium would be difficult. However, just doing a bit of research yielded some information about localStorage, which I ended up using for the login process, and after reading a couple more tutorials and revisiting some old code, I was able to get a "working" login page which set a variable in localStorage that I could compare against in other components to decide whether or not to render private events. 

Another problem I ran into was the issue of fetching the information for the related events on the event page: Initially, I wanted to do a fetch for the specified event, then do a Promise.all for the related events. However, I wasn't able to reliably load both fetches before the page attempted to render (resulting in attempting to get attributes of null elements). I was eventually able to perform both requests in the same function by chaining them and then having the page render only after both the event and its related events, if any, had been loaded in to the correct state variables.

One final, if a bit silly, problem is that since I was working on this project very late at night, I felt that the standard light mode that I was planning to implement was hurting my eyes while I was working. To combat this, I implemented a dark mode and made them toggleable for the user, and then I added a localStorage variable to save their choice across reloads, which I had learned while doing the login flow.


Pride Point(s)

I'm pretty happy with how the design ended up, and though it did stray from my original thought (ex. light/dark theme, shuffling elements around), it was fun messing around with padding and margins until I got something that I was happy with. I'm also proud of myself for finishing the project requirements in time and having enough time left to add some other features (ex. filtering/sorting, light/dark modes - more later) - when I first picked up the project, it seemed pretty daunting for someone who hadn't touched web development in a while. I'm also proud of myself for learning concepts and them immediately applying them elsewhere (ex. localStorage). In terms of reusability, I'm also generally happy with how the CSS classes came together (each class belonging to its own group or having a very specific attribute), since I was able to reuse practically all of them, making the styling part of development much more streamlined.



Extending and Reflecting on the Application

With additional time, I would definitely expand on the responsiveness of the web application. As it is now, it looks fine on screens around the size of a standard iPad, but since most of the bootstrap components are arranged in columns, smaller screens simply shrink the columns, rendering the text unreadable. I would come up with or work with someone to design a more responsive UI (ex. menu items collapsing into a sidebar, generally more mobile-friendly designs). Outside of that (and connecting it to a backend), and in regards to the other points on that list, I do believe that my code is clear and adequately documented (though I've never been sure about the correct folder structure for a React project) - I've left a few comments in each file to explain the more ambiguous or complex processes. I also believe that my project is scalable (ex. adding more events, adding more event types) since the former is simply a difference in how large the fetched array is and the latter amounts to another entry in the helper constants. Nothing is reliant on hard-coded information (aside from the login), and repeated components are rendered dynamically (ex. event cards on the main events page, the individual event pages). I did try to follow best practices in the event of continued development in that I tried naming my variables such that they correpond with the value(s) they represent, etc. If working in a team, however, I would try making better commits and more informative commit messages for the ease of my teammates and perhaps even myself if revisiting parts of a project. With a dark mode, I think that the project is at least generally visually accessible, although if I were to continue with the project I would certainly try to make it more responsive and increase the ease of use as much as possible. Finally, by using generally the same components (or types of components) as well as a consistent theme throughout the project (with the exception of the filtering checkboxes on the event page, which I was unable to figure out how to change), I think the appearance of the application is appealing. 


Additional Features

I chose to implement a few extra features outside of the four core functionalities. First, as already mentioned, a persisting and toggleable dark mode to not only provide more contrast but to also be easier on the eyes in dimmer environments. This feature actually helped me determine the best shade of each accent colour to use (or at least a "middle point"), as initially the colours were slightly too dark and then too light when I tried adjusting them for the dark mode. I eventually ended up at a compromise of sorts with which I am satisfied.

The second feature is a sorting dropdown, in which users can select one of three ways to sort the events as they appear on the main hub page. The sort is currently done right before the array of events is passed to the EventList component. As of right now, each "sort" is associated with a label for the dropdown as well as a lambda function to be used in the actual sorting process before the events are displayed, and the relationship between each of the dropdown elements is largely hardcoded since I wanted to enforce the ordering. In the future (or when working on a similar feature), I'd like to explore other ways of handling the shifting of elements in a component such as a dropdown while mostly preserving order.

The third major feature is a group of filtering options (which are currently only the event types). This filtering happens at the same time as the filtering based off of sign in state (after making the get request for the events but before the elements are set, so any elements that should stay hidden (ex. private ones) do stay hidden). The concept could be extended to other groups (ex. sponsor groups, starred events, etc.) as well, since the filter is simply a boolean check against one of the event's fields,

I also made a few minor design choices which (I hope) would increase the quality of a user's experience, such as rendering header-content groups only if the relevant content actually exists (so users would not see any hanging headers). There are also a few error messages, such as making a filtered request that returns no elements (ex. filtering for activities when not signed in) as well as an error message on the login page if the incorrect credentials are entered.

Overall, this was a fun project. I did spend more than 6-8 hours on it, but it served as both a good review and a good learning experience of frontend concepts and practices, and I hope you enjoyed evaluating it as much as I enjoyed making it.